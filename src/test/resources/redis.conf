# Redis 配置文件模板

# 注意单位：当需要内存大小时，可以指定,通常形式为1k 5GB 4M，以此类推：
#
# 1k => 1000 bytes
# 1kb => 1024 bytes
#
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
#
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
#
# 单元不区分大小写，所以1GB 1GB 1GB都是一样的.

# 默认情况下, Redis不作为守护进程运行. 如果需要, 请使用 'yes'
# 注意, Redis将在守护时在/var/run/Redis.pid中写入一个pid文件.
daemonize no

# 默认情况下, 运行daemonized时, Redis在/var/run/Redis.pid中写入一个pid文件
# 可以在此处指定自定义pid文件位置.
pidfile /var/run/redis.pid

# 接受指定端口上的连接, 默认值为6379.
# 如果指定端口0, Redis将不会侦听TCP套接字.
port 6379

# 默认情况下, Redis监听服务器上所有可用网络接口的连接.
# 可以使用 'bind' 配置指令只监听一个或多个接口,
# 使用 'bind' 配置指令的接口, 后跟一个或多个IP地址.
#
# 案例:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1

# 指定将用于侦听传入连接的 unix socket 的路径.
# 没有默认值, 因此未指定时, Redis不会侦听unix套接字.
#
# unixsocket /tmp/redis.sock
# unixsocketperm 755

# 在客户端空闲N秒后关闭连接 (0表示禁用)
timeout 0

# TCP 持久连接.
#
# 如果非零，则使用 SO_KEEPALIVE 在没有通信的情况下向客户端发送 TCP ACK.
# 这有两个原因：
#
# 1) 检测死同伴.
# 2) 从中间的网络设备的角度来看待连接.
#
# 在Linux上, 指定的值 (以秒为单位) 是用于发送ACK的周期.
# 请注意, 要关闭连接, 需要两倍的时间.
# 在其他内核上, 周期取决于内核配置.
#
# 此选项的合理值为60秒.
tcp-keepalive 0

# 指定服务器详细级别.
# 这可以是:
#   debug   (大量信息, 对开发/测试有用)
#   verbose (许多信息很少有用. 但不像调试级别那样混乱)
#   notice  (适度冗长, 可能是生产中需要的)
#   warning (仅记录非常重要/关键的消息)
loglevel notice

# 指定日志文件名. 也可以使用空字符串强制Redis登录标准输出.
# 注意, 如果使用标准输出进行日志记录, 但使用守护,日志将发送到/dev/null
logfile ""

# 要启用系统日志记录，只需将 'syslog enabled' 设置为 yes，
# 还可以选择更新其他syslog参数以满足您的需要。
# syslog-enabled no

# 指定系统日志标识.
# syslog-ident redis

# 指定syslog工具. 必须是用户或介于LOCAL0-LOCAL7之间.
# syslog-facility local0

# 设置数据库数. 默认数据库是DB 0,可以使用select<dbid>根据每个连接选择不同的数据库，
# 其中dbid是介于0和 'databases' 之间的数字 -1
databases 16

################################ 快照  #################################
#
# 将数据库保存在磁盘上:
#
#   save <seconds> <changes>
#
#   如果给定的秒数和针对数据库的给定写操作数同时发生, 则将保存数据库.
#
#   在下面的示例中, 行为将是保存：
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#
#   注意：您完全可以禁用保存, 对所有 '保存' 行进行注释.
#
#   还可以通过添加带有单个空字符串参数的 save 指令来删除以前配置的所有保存点,
#   如下例所示：
#
#   save ""

save 900 1
save 300 10
save 60 10000

# 默认情况下, 如果启用了RDB快照(至少一个保存点), 并且最新的后台保存失败, 则Redis将停止接受写入.
#
# 这将使用户(以硬方式)意识到数据没有正确地保存在磁盘上, 否则很可能没有人会注意到, 并且会发生一些错误.
#
# 如果后台保存过程将重新开始工作, Redis将自动允许再次写入.
#
# 但是，如果您设置了对Redis服务器和持久性的正确监视，则可能需要禁用此功能,
# 以便Redis可以继续正常工作, 即使磁盘、权限等方面存在问题。
stop-writes-on-bgsave-error yes

# dump.rdb 数据库时使用 LZF 压缩字符串对象？
# 默认设置为“是”，因为这几乎总是一场胜利.
# 如果要在保存子项中保存一些CPU, 请将其设置为 'no',
# 但如果有可压缩的值或键，则数据集可能会更大。
rdbcompression yes

# 因为RDB版本5，所以CRC64校验和放在文件的末尾。
# 这使得格式更能抵抗损坏, 但在保存和加载RDB文件时,
# 性能会受到影响(大约10%), 因此可以禁用它以获得最大性能.
#
# 在禁用校验和的情况下创建的RDB文件的校验和为零,
# 这将告诉加载代码跳过检查.
rdbchecksum yes

# 转储数据库的文件名
dbfilename dump.rdb

# 工作目录.
#
# 数据库将被写入这个目录中, 使用上面使用 'dbfilename' 配置指令指定的文件名.
#
# 只追加文件也将在此目录中创建.
# 请注意, 必须在此处指定目录, 而不是文件名.
dir ./

################################# REPLICATION #################################

# 主-从 复制. 使用 slaveof 使 Redis 实例成为另一个Redis服务器的副本.
# 注意, 该配置是从机的本地配置, 因此例如, 可以将从机配置为以不同的间隔保存数据库,
# 或者监听另一个端口, 等等.
#
# slaveof <masterip> <masterport>

# 如果主服务器受密码保护(使用下面的 'requirepass' 配置指令)，
# 则可以在启动复制同步过程之前通知从服务器进行身份验证，否则主服务器将拒绝从服务器请求。
#
# masterauth <master-password>

# 当从机失去与主机的连接或复制仍在进行时, 从机可以以两种不同的方式操作：
#
# 1) 如果 slave-serve-stale-data 设置为 'yes'(默认值), 则slave仍将答复客户端请求,
#    可能是过期数据, 或者如果这是第一次同步, 则数据集可能只是空的
#
# 2) 如果 slave-serve-stale-data 设置为 'no' , 则slave将对除 INFO 和 SLAVEOF 之外的
#    所有类型的命令回复错误 "SYNC with master in progress" .
slave-serve-stale-data yes

# 您可以将从属实例配置为是否接受写入. 针对从机实例的写入可能有助于存储一些短暂的数据(因为在与主服务器重新同步后,
# 在从机上写入的数据将很容易被删除),但如果客户端由于配置错误而向其写入数据, 则也可能导致问题.
#
# 因为Redis 2.6默认情况下从机是只读的.
#
# 注意: 只读从属服务器不设计为暴露给internet上不受信任的客户端.
# 它只是一个防止滥用实例的保护层. 默认情况下, 只读从机仍然导出所有管理命令, 如CONFIG、DEBUG等.
# 在有限的范围内, 您可以使用 'rename command' 来隐藏所有管理/危险命令, 从而提高只读从机的安全性.
slave-read-only yes

# 从服务器以预定义的间隔向服务器发送ping. 可以使用 repl_ping_slave_period 选项更改此间隔.
# 默认值为10秒
#
# repl-ping-slave-period 10

# 以下选项设置的复制超时:
#
# 1) 从从机的角度看,同步期间的大容量传输I/O.
# 2) 从从机(数据、ping)的角度来看主超时.
# 3) 从主服务器的角度来看从服务器超时(REPLCONF ACK pings).
#
# 务必确保此值大于为复制从机周期指定的值,
# 否则每次主设备和从设备之间的通信量较低时都会检测到超时.
#
# repl-timeout 60

# 同步后禁用从套接字上的 TCP 节点？
#
# 如果选择 'yes', Redis将使用较少的TCP数据包和较少的带宽向从机发送数据.
# 但这会增加数据在从机端出现的延迟, 对于使用默认配置的Linux内核, 延迟可达40毫秒.
#
# 如果选择 'no', 数据出现在从机端的延迟将减少, 但复制将使用更多带宽.
#
# 默认情况下, 我们会针对低延迟进行优化, 但在非常高的通信量条件下,
# 或者当主服务器和从服务器之间的跳数很多时. 将其设置为 'yes' 可能是一个好主意.
repl-disable-tcp-nodelay no


# 设置复制积压大小. backlog是一个缓冲区, 当从机断开连接一段时间后,
# 它会累积从机数据, 因此当从机想要重新连接时, 通常不需要完全重新同步,
# 但是部分重新同步就足够了, 只需传递从机在断开连接时丢失的部分数据
#
# 复制backlog越大, 从机断开连接的时间就越长, 以后就可以执行部分重新同步.
#
# 只有当至少有一个从机连接时, 才会分配backlog.
#
# repl-backlog-size 1mb

# 当主服务器在一段时间内不再连接从服务器后, 积压的工作将被释放.
# 以下选项配置从最后一个从属服务器断开连接开始释放积压缓冲区所需的秒数.
#
# 值为 0 意味着永远不会释放 backlog.
#
# repl-backlog-ttl 3600



# 从优先级是Redis在信息输出中发布的整数. Redis Sentinel使用它,
# 以便在主服务器不再正常工作时选择从服务器升级到主服务器.
#
# 优先级较低的从机被认为更适合提升, 例如, 如果有三个优先级为10、100、25的从机,
# 哨兵将选择优先级为10的从机, 即最低的.
#
# 但是, 特殊优先级为0, 则表示从机无法执行主机角色,
# 因此Redis Sentinel不会选择优先级为0的从机进行升级.
#
# 默认情况下，优先级为100.
slave-priority 100



# 如果连接的从属服务器少于N个，且延迟小于或等于M秒，则主服务器可以停止接受写入。
# N个奴隶需要处于“在线”状态。

# 以秒为单位的延迟（必须<=指定值）是从从机接收的最后一个ping（通常每秒发送一次）计算得出的。

# 此选项不保证N个副本将接受写操作，但会将丢失写操作的曝光窗口限制在指定的秒数内，以防没有足够的从机可用。
#
# 例如，需要至少3个滞后<=10秒的从机使用:
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# 将其中一个设置为0将禁用该功能。
#
# 默认情况下，要写入的最小从属设置为0（功能禁用），最小从属最大滞后设置为1



################################## 安全策略 ###################################

# 要求客户端在处理任何其他命令之前发出AUTH<PASSWORD>。在您不信任其他人可以访问运行redis服务器的主机的环境中，这可能很有用。
#
# 对于向后兼容性和因为大多数人不需要auth（例如，他们运行自己的服务器），这应该保持注释。
#
# 警告：由于Redis速度很快，外部用户可以在一个好的框中尝试每秒多达1500k个密码。这意味着你应该使用一个非常强的密码，否则很容易破解。
#
# requirepass foobared

# 命令重命名。
#
# 可以在共享环境中更改危险命令的名称。例如，CONFIG命令可能会被重命名为一些难以猜测的内容，以便它仍然可以用于内部使用的工具，但不能用于一般客户机。
#
# Example:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 也可以通过将命令重命名为空字符串来完全终止命令：
#
# rename-command CONFIG ""
#
# 请注意，更改记录到AOF文件或传输到从机的命令的名称可能会导致问题

################################### LIMITS ####################################

# 设置同时连接的最大客户端数。默认情况下，此限制设置为10000个客户端，
# 但是如果Redis服务器无法将进程文件限制配置为允许指定的限制，
# 则最大允许客户端数将设置为当前文件限制减去32（因为Redis保留一些文件描述符供内部使用）。
#
# 一旦达到限制，Redis将关闭所有新连接，并发送一个错误“max number of clients reached”。
# maxclients 10000

# 不要使用超过指定字节数的内存。当达到内存限制时，Redis将根据所选的逐出策略（请参阅maxmemmory策略）尝试删除键。
# 如果Redis无法根据策略移除密钥，或者策略被设置为“noeviction”，
# Redis将开始对使用更多内存的命令（如SET、LPUSH等）进行错误应答，并将继续对GET等只读命令进行应答。
# 当将Redis用作LRU缓存或设置实例的硬内存限制（使用“noeviction”策略）时，此选项通常很有用。
#
# 警告：如果将从属服务器连接到启用maxmemory的实例，则从已用内存计数中减去为从属服务器提供数据所需的输出缓冲区大小，
# 这样网络问题/resyncs就不会触发收回密钥的循环，反过来，从属服务器的输出缓冲区将充满收回的密钥增量，从而触发删除更多的密钥，
# 等等，直到数据库完全清空。简而言之。。。如果附加了从机，建议您为maxmemory设置一个lowerlimit，
# 以便系统上有一些空闲RAM用于slaveeoutput缓冲区（但如果策略为“noeviction”，则不需要这样做）。
#
# maxmemory <bytes>

# MAXMEMORY策略：当达到MAXMEMORY时，Redis将如何选择要删除的内容。您可以在五种行为中进行选择：
#
# volatile lru    -> 使用lru算法删除设置了expire的密钥
# allkeys lru     -> 根据lru算法移除任何密钥
# volatile random -> 删除带有过期集的随机密钥
# allkeys-random  -> 移除随机键，任意键
# volatile ttl    -> 删除最接近到期时间的密钥（次要ttl）
# noeviction      -> 根本不过期，只在写操作时返回一个错误
#
# 注意：使用上述任何策略，当没有合适的密钥可收回时，Redis将在写操作时返回错误。
#
#       At the date of writing this commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# The default is:
#
# maxmemory-policy volatile-lru


# LRU 和 minimal TTL算法不是精确算法，而是近似算法（为了节省内存），
# 因此您还可以选择要检查的样本大小。例如，对于default Redis，
# 将选中三个键并选择最近使用较少的键，您可以使用以下配置指令更改样本大小。
#
# maxmemory-samples 3

############################## APPEND ONLY MODE ###############################

# 默认情况下，Redis在磁盘上异步转储数据集。这种模式在许多应用程序中已经足够好了，
# 但是Redis进程的问题或断电可能会导致几分钟的写操作丢失（取决于配置的保存点）。

# Append Only文件是一种替代的持久性模式，它提供了更好的持久性。
# 例如，使用默认的数据fsync策略（请参阅配置文件的后面部分）Redis在服务器断电之类的重大事件中可能会丢失一秒钟的写入，
# 或者在Redis进程本身出现问题时丢失一次写入，但操作系统仍在正常运行。

# 可以同时启用AOF和RDB持久性，而不会出现问题。如果在启动时启用了AOF，Redis将加载AOF，
# 即具有更好的持久性保证的文件。有关详细信息，请查看http://redis.io/topics/persistence。

appendonly no

# 仅追加文件的名称（默认值：“append only.aof”）append file name appendonly.aof

# fsync() 调用告诉操作系统实际在磁盘上写入数据，而不是在输出缓冲区中等待更多数据。
# 一些操作系统将真正刷新磁盘上的数据，一些其他操作系统将尝试尽快这样做。
#
# Redis支持三种不同的模式：
#
# no：不要fsync，只要让操作系统在需要的时候刷新数据就行了。更快。
# always：每次写入仅追加日志后fsync。慢点，最安全。
# everysec: 每秒钟只同步一次
#
# 默认值是“everysec”，因为这通常是速度和数据安全之间的正确折衷。
# 这取决于您是否可以将其放宽到 “no”，这将让操作系统在需要时刷新输出缓冲区，
# 以获得更好的性能（但如果您能够接受某些数据丢失的想法，请考虑快照的默认持久性模式），
# 或者相反，使用“always”这一速度非常慢，但比everysec安全一些。
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# 如果不确定，使用 "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no

# 当fsync为always或者everysec，当一个bgsave或者AOF rewrite线程正在耗费大量I/0，redis可能会在fsync上阻塞很久。
# 发生之后就无法fix，即使是另一个线程跑fsync，也会阻塞我们同步的write方法。
# 如下方法可以解决这个问题：当bgsave()或bgrewriteaof()在跑，主进程的fsync()就无法调用。
# 也就是当子进程在save，那段时光相当于redis是appendaof no的。也就是有可能会丢失最多30s的log。
# 所以如果你有lag问题，把下边改成yes，否则就用no。yes意思是暂停aof，
# 拒绝主进程的这次fsync。no是redis是排队的，不会被prevent了，但主进程是阻塞的。
no-appendfsync-on-rewrite no

# 自动重写AOF
# 当AOF文件大小到一定比例，就自动隐式调用BGREWRITEAOF
# 过程：redis记住最后一次rewrite时aof文件大小（重启后没rewrite的话，就是启动时AOF文件的大小），
# 如果现在AOF大小和上次的比例达到特定值就重写。也要指定最小AOF大小，防止到2倍：1M的时候也重写。
# 把percentage改成0，就是禁用重写。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

################################ LUA SCRIPTING  ###############################

# 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。
# 当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。
# 要是已经调用了write，只能用第二个命令杀。
# 设置成0或者负值，时限就无限。
lua-time-limit 5000

################################## SLOW LOG ###################################

# 线程阻塞不能服务其他请求的时间长度。两个参数：第一个是时长（以微秒为单位！，是毫秒的千分之一。）。
# 第二个是log的size，超过了，就会删除之前的log。
# 1000000是一秒。负值是所有请求都记log！下边是0.10S。100毫秒。
slowlog-log-slower-than 10000

# log长度的设置值是没限制。但是需要内存。
# 您可以使用slow log RESET回收慢日志使用的内存。
slowlog-max-len 128

############################# Event notification ##############################

# Redis可以通知Pub/Sub客户端密钥空间中发生的事件。
# 此功能记录在http://redis.io/topics/keyspace-events
#
# 例如，如果启用了keyspace事件通知，并且客户端对存储在数据库0中的键“foo”执行DEL操作，
# 则将通过Pub/Sub发布两条消息：
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# 可以在一组类中选择Redis将通知的事件。每个类都由一个字符标识：
#
# K     Keyspace events, published with __keyspace@<db>__ prefix.
# E     Keyevent events, published with __keyevent@<db>__ prefix.
# g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
# $     String commands
# l     List commands
# s     Set commands
# h     Hash commands
# z     Sorted set commands
# x     Expired events (events generated every time a key expires)
# e     Evicted events (events generated when a key is evicted for maxmemory)
# A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#
# “notify keyspace events ” 将零个或多个字符组成的字符串作为参数。空字符串表示通知完全被禁用。
#
# 示例：要启用列表和泛型事件，请从事件名称的角度使用：
#
# notify-keyspace-events Elg
#
# 示例2:若要获取订阅频道名称keyevent@0的过期密钥流，请使用：
#
# notify-keyspace-events Ex
#
# 默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，而且此功能有一些开销。请注意，
# 如果未指定K或E中的至少一个，则不会传递任何事件

notify-keyspace-events ""

############################### ADVANCED CONFIG ###############################

# 当哈希有少量的条目，并且最大的条目不超过给定的阈值时，使用内存高效的数据结构对其进行编码。
# 可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# 与散列类似，为了节省大量空间，小列表也以特殊的方式进行编码。
# 仅当您处于以下限制下时，才使用特殊表示：
list-max-ziplist-entries 512
list-max-ziplist-value 64

# 集合只有一种特殊的编码方式：集合只由64位有符号整数范围内的基数为10的整数组成。
# 以下配置设置设置集大小的限制，以便使用此特殊的内存保存编码。
set-max-intset-entries 512

# 与散列和列表类似，经过排序的集也经过特殊编码，以节省大量空间。
# 此编码仅在排序集的长度和元素低于以下限制时使用：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# 活动的重新灰化每100毫秒CPU时间使用1毫秒，以帮助重新灰化主Redis哈希表（将顶级键映射到值的表）。
# Redis使用的哈希表实现（参见dict.c）执行一个延迟的重新灰化：在重新灰化的哈希表中运行的操作越多，
# 执行的重新灰化“步骤”就越多，因此，如果服务器空闲，则重新灰化永远不会完成，哈希表将使用更多的内存。
#
# 默认情况下，每秒使用此毫秒10次，以便主动重新整理主词典，尽可能释放内存。
#
# 如果不确定：
# 如果您有硬延迟要求，并且在您的环境中，Redis可以用2毫秒的延迟来答复查询，
# 这不是一件好事，请使用“activerehashing no”。
#
# 如果您没有这么高的要求，但希望在可能的情况下尽快释放内存，请使用“activerehashing yes”。
activerehashing yes

# 客户机输出缓冲区限制可用于强制断开由于某些原因没有足够快地从服务器读取数据的客户机的连接
# （一个常见的原因是发布服务器/子客户机无法以发布服务器能够生成的速度使用消息）。
#
# 对于三种不同类型的客户机，可以设置不同的限制：
#
# normal -> 普通客户
# slave  -> 从客户端和监视客户端
# pubsub -> 至少订阅了一个pubsub频道或模式的客户端
#
# 每个客户机输出缓冲区限制指令的语法如下：
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# 一旦达到硬限制，或达到软限制并保持达到指定秒数（连续）时，客户端将立即断开连接。
#
# 因此，例如，如果硬限制为32兆字节，软限制为16兆字节/10秒，则如果输出缓冲区的大小达到32兆字节，
# 则客户端将立即断开连接，但如果客户端达到16兆字节并连续超过该限制10秒，则客户端也将断开连接。
#
# 默认情况下，普通客户机不受限制，因为它们不会在没有请求（以推送方式）的情况下接收数据，
# 而是在请求之后才接收数据，因此只有异步客户机可能会创建这样一个场景：
#   请求数据的速度比读取数据的速度快
#
# 相反，pubsub和slave客户端有一个默认限制，因为订阅者和slave以推送方式接收数据。
#
# 硬限制或软限制都可以通过将其设置为零来禁用。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis调用一个内部函数来执行许多后台任务，
# 比如在timeot中关闭客户端的连接，清除从未请求过的过期密钥，等等。
#
# 并非所有任务都以相同的频率执行，但Redis会根据指定的“hz”值检查要执行的任务。
#
# 默认情况下，“hz”设置为10。当Redis空闲时，提高这个值将使用更多的CPU，
# 但同时当有许多密钥同时过期时，Redis将更具响应性，并且可以更精确地处理超时。
#
# 范围在1到500之间，但是值超过100通常不是一个好主意。大多数用户应该使用默认值10，
# 并且仅在需要非常低延迟的环境中才将此值提高到100。
hz 10

# 当一个子对象重写aof文件时，如果启用了以下选项，则每生成32 MB的数据就会对该文件进行fsync。
# 这对于更增量地将文件提交到磁盘并避免较大的延迟峰值非常有用。
aof-rewrite-incremental-fsync yes

################################## INCLUDES ###################################

# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis server but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
#
# include /path/to/local.conf
# include /path/to/other.conf